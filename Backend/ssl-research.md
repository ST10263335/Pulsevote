**Answers**

**Rate Limiting** Summary Rate limiting is a security technique that controls how many requests a client can make to an API within a set time window, preventing abuse and protecting resources. It is especially critical for authentication endpoints like login and registration, since without limits attackers can brute‑force passwords or script mass account creation. Per‑IP limits restrict requests from a single network address, while per‑identifier limits (such as per‑email) add an extra layer by throttling repeated attempts against the same account. Reverse proxies and load balancers can obscure the true client IP, so applications must be configured to trust proxy headers correctly to avoid inaccurate enforcement. Safe defaults (e.g., 5 attempts per 10–15 minutes) are fine for development, but production systems often need stricter, context‑aware settings to balance user experience with strong protection against automated attacks.

**Linting** ensures code quality by catching syntax errors and enforcing style rules before runtime. Unit tests validate small pieces of functionality, making sure each part of the code behaves as expected. Together, they are critical for building reliable, maintainable software and can be fully automated in CI/CD pipelines. In a Node.js API, linting is commonly done with ESLint, while unit testing is handled with frameworks like Mocha or Jest. Flaky tests undermine confidence in the test suite, waste developer time, and can delay releases. Maintaining stable, automated linting and testing workflows is essential for long-term project health.

**Docker** is a platform that allows developers to package applications and their dependencies into portable containers, ensuring consistency across environments. Docker Compose extends this by enabling multi‑container setups, such as running a Node.js API alongside a database, with a single configuration file. These tools are essential because they simplify deployment, improve scalability, and eliminate the “works on my machine” problem. Building and running containers can be fully automated through CI/CD pipelines, making delivery faster and more reliable. To dockerize a Node.js API, you typically write a Dockerfile that installs dependencies, copies code, and runs the server, then use Docker Compose if additional services are needed. Together, Docker and Docker Compose form a cornerstone skillset for modern software development and DevOps.